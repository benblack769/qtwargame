MaxAttackRange = const c #s.t. c^2*boardsize is reasonable (<20,000,000 or so perferably)


TroopProb := Move->(Troop->(P->value))
TroopVal := Move->(Troop->(P->value))
#keeps the probabilty of various troops being in a single location from exceeding 1.0
ChanceSomethingThere := Move->(Point->(Prob default 0))

#accumulates all attacks against certain units

#this represents the best attack of a single troop against the many targets it has.
#it does not represent the optimal attack senario including all attacking units, I belive this too slow of a problem.
all_attacks_prob := Move->(DT->(Point->Prob))

prob_add(x,y) = x + y - (x * y)

prob_sum_of [] = 0
	| L = prob_add(hd(L),prob_sum_of(tl(L)))

#todo: rethink values of buildings
Val(T,M,P) = (if IsBuilding(T)
			 then Cost(T)
			 else (Cost(T) + FutureMoveVal(T,M,P))
			 ) / T.hitpoints() #todo: try different ways to make value dependent on how much it has already been killed

#WinChance is a huristic that estimates the sort of ability of one troop to destroy another and vice versa.
#it is almost certainly redundant with the entire value/probability system.
AttackTroopPointProb(AT,DT,M,AP,DP) = MoveProb(DT,M,DP) # * WinChance(AT,DT)

#represents best attack from a single point against its many targets
TroopAttackValGather(AT,M,AP) := ((DT,DP)->prob)

    tpvals = [ValInfo<Val(DT,M,DP), AttackTroopPointProb(AT,DT,M,AP,DP)>
                for DT in EnemyTroops
                    for DP in square_range(AP,AT.range) exclude AP]
    tpvals = sort(tpvals,greatest_in_front)

    tprobs := (Troop->Prob)
    attacks := ((DT,DP)->prob)

    tot_prob = 0
    for (prob_base,troop,TP) in tpvals:
        attprob = prob_base * (1 - tot_prob)
        tot_prob += attprob
        attacks[troop,TP] = attprob
        #notice that this keeps it so that many attacking units do not overattack a unit
        TroopProb.LastCalculatedMove[troop][TP] -= attprob * TroopProb[M][AT][AP]
        #allows for values to be altered by attacks as well calculation
        all_attacks_prob.LastCalculatedMove[troop][TP] (prob)+= attprob

    return attacks

AttackVal(AT,M,AP) = sum_of(Val(DT,M,DP) * TroopAttackValGather(AT,M,AP)[DT,DP] for DT in EnemyTroops for DP in square_range(AP,AT.range) exclude AP)

NetValModifier(T,M,P) = (AttackVal(T,M,P) - Val(T,M,P) * all_attacks_prob[M][T][P])

#accumulates the value of moving to locations along optimal path from origin
MoveToVal(T,0,P) = NetValModifier(T,0,P)
        | MoveToVal(T,M,P) =
                        NetValModifier(T,M,P) +
                                max_of(
                                        MoveToVal(T,M-1,P)
                                        for P in square_range(P,1)
                                )

#represents the total value of the optimal path of the troop both forwards and backwards in time assuming being on a point at move M
MovePathVal(T,MaxM,P) = MoveToVal(T,MaxM,P)
	| MovePathVal(T,M,P) =
		(max_of( MovePathVal(T,M+1,NextP))
				for NextP in square_range(P,1))
			- (MoveToVal(T,M+1,P) - NetValModifier(T,M+1,P)) #the value of the best child move of M+1 (>= MoveToVal(T,M,P))
			+ MoveToVal(T,M,P)

#represents the accumulated value of the move path ahead of it
FutureMoveVal(T,M,P) = MovePathVal(T,M,P) + NetValModifier(T,M,P) - MoveToVal(T,M,P)

LandVal(Play) = #look at how landVal is calculated in the code

ValModfier(V) = V #todo:consider making this non-liniar

#requirements for moveprob
# 1. sumof(MoveProb(T,M,P) for T in AllTroops) <= 1.0
# 2. sumof(MoveProb(T,M,P) for P in Board) <= T.NumOfSquaresOccupied
# 3. MoveProb deteriorates with attacks according to the probabilies of them happening

/*
Basic idea how moveprob works:

Values are the dollar value of a troop being in a location. The value does not depend on how the likelyhood of
the troop actually being there or any other quantity, only the troops it can attack, the land it can get and other quantities.

Takes the value from the previous iteration, and uses it as a guide on making a set of probailities of future move points that
is consistent with basic movement rules and also attacking mechanics.

More nuanced idea of how this works:

*/

MoveProb(0,T) := (Point->Prob)
    probs :=  (Point->(Prob default 0))
    probs[T.P] = 1.0
    return probs


MoveProb(M,T,TroopVals) := (Point->Prob)
    probs :=  (Point->(Prob default 0))
    prevps = MoveProb(M-1,T)
    for BP in Board:
        already_taken_total = sum_of(ChanceSomethingThere[M][P] for P in SquareIter(BP,T.movmementrange))
        base_move_possibilties = sum_of(1 for P in SquareIter(BP,T.movmementrange))

        for PP in SquareIter(BP,T.movmementrange):
            #not enough probabilty to maintain itself
            if(base_move_possibilties - already_taken_total < move_prev_prob[P]):
                #takes all the probaility left, if this ever happens, then it kind of skrews things up
                #because it is as if it were attacked.
                prob = 1.0 - ChanceSomethingThere[M}[PP]
            else:
                stable_val_modifier = ValModfier(TroopVals[M][T][BP])) / sum_of(ValModfier(TroopVals[M][T][BP]) for MP in SquareIter(BP,1));
                for PP in SquareIter(BP,1):
                `   #TODO:work this out, it doesn't really work all hat well now.
                    probs[PP] += prevps[BP] * stable_val_modifier

    return probs


main_calc():
    Set all TroopVals = 1.0 # initial setting for first iteration calculation LONGTERM TODO: change to value heristic like for builidngs and trainings
    for iter in range(NUM_ITERS):
        set_to_default(ChanceSomethingThere)
        set_to_default(TroopProb)

        for M in range(MAXMOVES):
            for play in PlayOrder(Players):
                #performs attacks (decreases on probabilty) on other players probabilty values as it calculates its own probabilties.
                #note that final move will not be attacked in this way, so it will be flawed.

                # sequencial algorithm, troop ordering matters, but there is currently
                # no ordering mechanism to optimize this process, so it is randomized to reduce impact on outcome
                for T in random_order(P.Troops):
                    TroopProb[T] = MoveProb(M,T)

        #all attacks taken into account, so values can now be calculated
        TroopVals = FutureMoveVal(T,M,P)
                        for M in range(MAXMOVES)
                            for T in AllTroops
                                for P in ConstSquares




#Micro Move

val_attack(0,T,MP,AP) > 0 #todo:list the actual initial value here
	| val_attack(I,T,MP,AP) = val_attack(I-1,T,MP,AP) - val_attack(I-1,T,MP,AP) *
		sum(
			sum(val_adj(I-1,AT,AMP,AP) for AMP in AT.movebox)
			for AT in EnemyTroops
		)

val_move(T,P)
val_tot(T,MP) = val_move(T,MP) + sum(val_attack(T,P))
adjval_m(T,M)
adjval_a(T,M,A)
