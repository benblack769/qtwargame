MaxAttackRange = const c #s.t. c^2*boardsize is reasonable (<20,000,000 or so perferably)

prob_add(x,y) = x + y - (x * y)

prob_sum_of [] = 0
	| L = prob_add(hd(L),prob_sum_of(tl(L)))

Val(T,M,P) = (if IsBuilding(T)
			 then Cost(T)
			 else (Cost(T) + FutureMoveVal(T,M,P))
			 ) / T.hitpoints() #todo: try different ways to make value dependent on how much it has already been killed

ChanceSomethingThere(P,M) = prob_add(BuildProb(P,M),prob_sum_of(MoveProb_PrevIteration(T,M,P) for T in AllTroops))

AttackTroopPointProb(AT,DT,M,AP,DP) = MoveProb_PrevIteration(DT,M,DP) * WinChance(AT,DT) #todo: check that MoveProb makes sense in this context

all_attacks_prob(M) := ((DT,Point)->Prob)

TroopAttackValGather(AT,M,AP) := ((DT,DP)->prob)

    tpvals = [ValInfo<Val(DT,M,DP), AttackTroopPointProb(AT,DT,M,AP,DP)>
                for DT in EnemyTroops
                    for DP in square_range(AP,AT.range) exclude AP]
    tpvals = sort(tpvals,greatest_in_front)

    tprobs := (Troop->Prob)
    attacks := ((DT,DP)->prob)

    tot_prob = 0
    for (val,prob_base,troop,TP) in tpvals:
        attprob = prob_base * (1 - tot_prob)
        tot_prob += attprob
        attacks[troop,TP] = attprob
        all_attacks_prob(M)[troop,TP] (prob)+= attprob

    return attack

AttackVal(AT,M,AP) = sum_of(Val(DT,M,DP) * TroopAttackValGather(AT,M,AP)[DT,DP] for DT in EnemyTroops for DP in square_range(AP,AT.range) exclude AP)

NetValModifier(T,M,P) = (AttackVal(T,M,P) - Val(T,M,P) * all_attacks_prob(M)[T,P]) * (1 - ChanceSomethingThere(P,M))#todo:check ChanceSomethingThere for necessity and consistencys

#accumulates the value of moving to locations
MoveToVal(T,0,P) = NetValModifier(T,0,P)
        | MoveToVal(T,M,P) =
                        NetValModifier(T,M,P) +
                                max_of(
                                        MoveToVal(T,M-1,P)
                                        for P in square_range(P,1)
                                )

#represents the total value of the path the troop is traveling on both forwards and backwards in time
MovePathVal(T,MaxM,P) = MoveToVal(T,MaxM,P)
	| MovePathVal(T,M,P) =
		(max_of( MovePathVal(T,M+1,P), P)
				for P in square_range(P,1))
			- (MoveToVal(T,M+1,P) - NetValModifier(T,M+1,P)) #the value of the best child move of M+1 (>= MoveToVal(T,M,P))
			+ MoveToVal(T,M,P)

#represents the accumulated value of the move path ahead of it
FutureMoveVal(T,M,P) = MovePathVal(T,M,P) + NetValModifier(T,M,P) - MoveToVal(T,M,P)

ValModfier(V) = V #todo:consider making this non-liniar

MoveProb(T,0) := (Point->Prob)
    probs :=  (Point->(Prob default 0))
    probs[T.P] = 1.0
    return probs

MoveProb(T,M) := (Point->Prob)
    probs :=  (Point->(Prob default 0))
    prevps = MoveProb(T,M-1)
    for BP in Board:
		ValRat (Point->Ratio)
		#normal value ratios
		for MP in SquareIter(BP,1):
			ValRat[MP] = ValModfier(MovePathVal(T,M,MP)) / sum_of(ValModfier(MovePathVal(T,M,MMP)) for MMP in AllSqares)
			
		adjval = 0
        for PP in SquareIter(BP,1):
            probmul = probs[BP] * prevps[PP]
			valadd = ValRat[PP] * (probs[BP] - probmul) #basically a probability add
			probs[PP] += valadd
			#we need sumof(valadd over range) to be probs[BP]
			
			ValRat = (1 - probmul)
    return probs

MoveProb(T,M,P) = ValModfier(MovePathVal(T,M,P)) / sum_of(ValModfier(MovePathVal(T,M,MP)) for MP in AllSqares)

LandVal(Play) = #look at how landVal is calculated in the code

#Micro Move

val_attack(0,T,MP,AP) > 0 #todo:list the actual initial value here
	| val_attack(I,T,MP,AP) = val_attack(I-1,T,MP,AP) - val_attack(I-1,T,MP,AP) *
		sum(
			sum(val_adj(I-1,AT,AMP,AP) for AMP in AT.movebox)
			for AT in EnemyTroops
		)

val_move(T,P)
val_tot(T,MP) = val_move(T,MP) + sum(val_attack(T,P))
adjval_m(T,M)
adjval_a(T,M,A)
